Below is a distilled, comprehensive mathematical and theoretical framework for Phase 1 (Pure Math) of the trading bot project. This serves as the foundation before any coding begins. The focus is on deterministic, mathematically sound methods without machine learning models, ensuring a robust baseline that applies well-understood statistical techniques, probability assessments, and risk management to guide trading decisions on Hyperliquid or similar exchanges.
Core Objectives of Phase 1

    Data-Driven, Non-ML Signals:
    All entry and exit decisions derive from mathematical and statistical calculations. No machine learning predictions are used at this stage. Instead, we rely on:
        Technical indicators (EMAs, Stochastics, Fibonacci retracements)
        Basic time-series models (ARIMA for returns, GARCH for volatility)
        Deterministic probability and EV calculations.

    Clear, Reproducible Logic:
    Each decision can be traced back to a formula or threshold. The strategy is transparent and academically rigorous, suitable for demonstration as a "PhD-level" trading system.

Theoretical Components

    Price and Return Modeling:

        Log Returns:
        Given a price series (pt)(pt​), the log return is:
        rt=log⁡(ptpt−1).
        rt​=log(pt−1​pt​​).

        These returns serve as the primary time-series input for ARIMA and GARCH models.

        ARIMA for Return Forecasting: A simple ARIMA model on past returns estimates the expected next period’s return:
        r^t+1=ARIMA(rt;p,d,q)
        r^t+1​=ARIMA(rt​;p,d,q)

        This forecast gives a point estimate of the next return. Converting it to a price-level expectation:
        p^t+1=ptexp⁡(r^t+1).
        p^​t+1​=pt​exp(r^t+1​).

    Volatility Estimation (GARCH): GARCH models capture volatility clustering. From historical log returns (rt)(rt​):
    σ^t+12=ω+αrt2+βσ^t2,
    σ^t+12​=ω+αrt2​+βσ^t2​,

    where ω,α,βω,α,β are GARCH parameters. The resulting σ^t+1σ^t+1​ provides a volatility forecast, used for volatility-adjusted position sizing.

    Technical Indicators:

        EMA (Exponential Moving Average):
        The short-term and long-term EMAs are:
        EMAshort(t)=EMA(pt;spans),EMAlong(t)=EMA(pt;spanℓ).
        EMAshort​(t)=EMA(pt​;spans​),EMAlong​(t)=EMA(pt​;spanℓ​).

        A bullish bias might be signaled by EMAshort(t)>EMAlong(t)EMAshort​(t)>EMAlong​(t).

        Stochastic Oscillator:
        Over a recent window nn:
        Stoch(t)=100⋅pt−min⁡[t−n,t](p)max⁡[t−n,t](p)−min⁡[t−n,t](p).
        Stoch(t)=100⋅max[t−n,t]​(p)−min[t−n,t]​(p)pt​−min[t−n,t]​(p)​.

        Stochastics help identify overbought/oversold conditions.

        Fibonacci Retracements: From a recent swing high pHpH​ and swing low pLpL​, Fibonacci levels are:
        pfib(f)=pL+f(pH−pL),f∈{0.236,0.382,0.5,0.618,0.786}.
        pfib​(f)=pL​+f(pH​−pL​),f∈{0.236,0.382,0.5,0.618,0.786}.

        Check proximity to these levels to identify support/resistance and confirm trade entries or exits.

    Probability and Expected Value (EV): Without ML, puppup​ (the probability of an upward move) can be derived from:
        Historical strike rate of the strategy’s conditions.
        A simple heuristic: for instance, if ARIMA suggests a positive expected return and trend signals are bullish, assign puppup​ = some fraction > 0.5. If conditions are neutral, pup≈0.5pup​≈0.5.

    Once puppup​ is established, compute EV:
        Let:
        Rwin=(p^t+1−pt)(expected gain if move is up),
        Rwin​=(p^​t+1​−pt​)(expected gain if move is up),
        Rloss=(pt−pstop)(expected loss if trade fails),
        Rloss​=(pt​−pstop​)(expected loss if trade fails), where pstoppstop​ is a stop-loss level.

    Include fees and slippage cc:
    EV=pup(Rwin−c)−(1−pup)(Rloss+c).
    EV=pup​(Rwin​−c)−(1−pup​)(Rloss​+c).

    Only trade if:
    EV>0.
    EV>0.

    Position Sizing (Volatility and Kelly Criterion): Incorporate volatility scaling and Kelly fraction:
        Compute a Kelly fraction based on puppup​ and ratio r=Rwin∣Rloss∣r=∣Rloss​∣Rwin​​:
        f∗=pup−1−pupr.
        f∗=pup​−r1−pup​​.

    If f∗<0f∗<0, do not trade. If f∗>0f∗>0, consider using a fraction of f∗f∗ for risk control.
        Volatility scaling:
        qtybase=Balance×RISK_FACTORpt×σ^t+1
        qtybase​=pt​×σ^t+1​Balance×RISK_FACTOR​

    Final quantity:
    qty=qtybase×max⁡(0,f∗)
    qty=qtybase​×max(0,f∗)

    If the resulting quantity is below a minimum order size, either skip the trade or adjust to the minimum.

    Trend and Regime Filters:
        If EMAshort(t)>EMAlong(t)EMAshort​(t)>EMAlong​(t), bias long trades only.
        Use heuristic conditions to reduce puppup​ if volatility is high or indicators are conflicting.
        If conditions produce pup<PROB_THRESHOLDpup​<PROB_THRESHOLD, skip the trade.

    Scenario Testing and Additional Filters: Run scenario stress tests on EV by slightly varying parameters (e.g., slightly higher slippage or lower puppup​) to ensure the trade remains positive EV under small perturbations. If not:
    Do not trade.
    Do not trade.

Outcome

This mathematical framework provides a strict, academically rigorous foundation:

    No ML: Purely mathematical/statistical signals ensure full transparency.
    Probability and EV Logic: Every trade is governed by a simple, mathematically justifiable formula ensuring a positive expected outcome before execution.
    Risk Management: Kelly sizing and volatility adjustments ensure trades scale with market conditions.
    Filters and Thresholds: Trend confirmation and probability thresholds ensure only the highest quality signals translate into trades.

In summary, Phase 1 yields a sophisticated, math-only trading system that can stand on its own as a "PhD-level" demonstration of quantitative trading principles, ready to be extended with machine learning in Phase 2.




Core Objectives of Phase 1

    Data-Driven, Non-ML Signals:
    All entry and exit decisions derive from mathematical and statistical calculations. No machine learning predictions are used at this stage. Instead, we rely on:
        Technical indicators (EMAs, Stochastics, Fibonacci retracements)
        Basic time-series models (ARIMA for returns, GARCH for volatility)
        Deterministic probability and EV calculations.

    Clear, Reproducible Logic:
    Each decision can be traced back to a formula or threshold. The strategy is transparent and academically rigorous, suitable for demonstration as a "PhD-level" trading system.

Theoretical Components

    Price and Return Modeling:

        Log Returns:
        Given a price series (pt)(pt​), the log return is:
        rt=log⁡(ptpt−1).
        rt​=log(pt−1​pt​​).

        These returns serve as the primary time-series input for ARIMA and GARCH models.

        ARIMA for Return Forecasting: A simple ARIMA model on past returns estimates the expected next period’s return:
        r^t+1=ARIMA(rt;p,d,q)
        r^t+1​=ARIMA(rt​;p,d,q)

        This forecast gives a point estimate of the next return. Converting it to a price-level expectation:
        p^t+1=ptexp⁡(r^t+1).
        p^​t+1​=pt​exp(r^t+1​).

    Volatility Estimation (GARCH): GARCH models capture volatility clustering. From historical log returns (rt)(rt​):
    σ^t+12=ω+αrt2+βσ^t2,
    σ^t+12​=ω+αrt2​+βσ^t2​,

    where ω,α,βω,α,β are GARCH parameters. The resulting σ^t+1σ^t+1​ provides a volatility forecast, used for volatility-adjusted position sizing.

    Technical Indicators:

        EMA (Exponential Moving Average):
        The short-term and long-term EMAs are:
        EMAshort(t)=EMA(pt;spans),EMAlong(t)=EMA(pt;spanℓ).
        EMAshort​(t)=EMA(pt​;spans​),EMAlong​(t)=EMA(pt​;spanℓ​).

        A bullish bias might be signaled by EMAshort(t)>EMAlong(t)EMAshort​(t)>EMAlong​(t).

        Stochastic Oscillator:
        Over a recent window nn:
        Stoch(t)=100⋅pt−min⁡[t−n,t](p)max⁡[t−n,t](p)−min⁡[t−n,t](p).
        Stoch(t)=100⋅max[t−n,t]​(p)−min[t−n,t]​(p)pt​−min[t−n,t]​(p)​.

        Stochastics help identify overbought/oversold conditions.

        Fibonacci Retracements: From a recent swing high pHpH​ and swing low pLpL​, Fibonacci levels are:
        pfib(f)=pL+f(pH−pL),f∈{0.236,0.382,0.5,0.618,0.786}.
        pfib​(f)=pL​+f(pH​−pL​),f∈{0.236,0.382,0.5,0.618,0.786}.

        Check proximity to these levels to identify support/resistance and confirm trade entries or exits.

    Probability and Expected Value (EV): Without ML, puppup​ (the probability of an upward move) can be derived from:
        Historical strike rate of the strategy’s conditions.
        A simple heuristic: for instance, if ARIMA suggests a positive expected return and trend signals are bullish, assign puppup​ = some fraction > 0.5. If conditions are neutral, pup≈0.5pup​≈0.5.

    Once puppup​ is established, compute EV:
        Let:
        Rwin=(p^t+1−pt)(expected gain if move is up),
        Rwin​=(p^​t+1​−pt​)(expected gain if move is up),
        Rloss=(pt−pstop)(expected loss if trade fails),
        Rloss​=(pt​−pstop​)(expected loss if trade fails), where pstoppstop​ is a stop-loss level.

    Include fees and slippage cc:
    EV=pup(Rwin−c)−(1−pup)(Rloss+c).
    EV=pup​(Rwin​−c)−(1−pup​)(Rloss​+c).

    Only trade if:
    EV>0.
    EV>0.

    Position Sizing (Volatility and Kelly Criterion): Incorporate volatility scaling and Kelly fraction:
        Compute a Kelly fraction based on puppup​ and ratio r=Rwin∣Rloss∣r=∣Rloss​∣Rwin​​:
        f∗=pup−1−pupr.
        f∗=pup​−r1−pup​​.

    If f∗<0f∗<0, do not trade. If f∗>0f∗>0, consider using a fraction of f∗f∗ for risk control.
        Volatility scaling:
        qtybase=Balance×RISK_FACTORpt×σ^t+1
        qtybase​=pt​×σ^t+1​Balance×RISK_FACTOR​

    Final quantity:
    qty=qtybase×max⁡(0,f∗)
    qty=qtybase​×max(0,f∗)

    If the resulting quantity is below a minimum order size, either skip the trade or adjust to the minimum.

    Trend and Regime Filters:
        If EMAshort(t)>EMAlong(t)EMAshort​(t)>EMAlong​(t), bias long trades only.
        Use heuristic conditions to reduce puppup​ if volatility is high or indicators are conflicting.
        If conditions produce pup<PROB_THRESHOLDpup​<PROB_THRESHOLD, skip the trade.

    Scenario Testing and Additional Filters: Run scenario stress tests on EV by slightly varying parameters (e.g., slightly higher slippage or lower puppup​) to ensure the trade remains positive EV under small perturbations. If not:
    Do not trade.
    Do not trade.

Outcome

This mathematical framework provides a strict, academically rigorous foundation:

    No ML: Purely mathematical/statistical signals ensure full transparency.
    Probability and EV Logic: Every trade is governed by a simple, mathematically justifiable formula ensuring a positive expected outcome before execution.
    Risk Management: Kelly sizing and volatility adjustments ensure trades scale with market conditions.
    Filters and Thresholds: Trend confirmation and probability thresholds ensure only the highest quality signals translate into trades.